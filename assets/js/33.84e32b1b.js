(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{456:function(t,e,a){"use strict";a.r(e);var r=a(2),v=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"watch-和-watcheffect-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#watch-和-watcheffect-的区别"}},[t._v("#")]),t._v(" "),e("strong",[t._v("watch 和 watchEffect 的区别？")])]),t._v(" "),e("ul",[e("li",[t._v("watch 既要指明数据源，又要指明监听的回调")]),t._v(" "),e("li",[t._v("watch 可以自动监听数据源作为依赖，不用指明监听哪个数据，监听回调用到哪个数据就会自动监听哪个数据")]),t._v(" "),e("li",[t._v("watch 可以访问改变前后的值，watchEffect 只能获取改变后的值")]),t._v(" "),e("li",[t._v("watch 运行的时候不会立即执行，值改变后才会执行（可通过 immeriate 改变）；而 watchEffect 运行后就立即执行")])]),t._v(" "),e("h3",{attrs:{id:"ref-与-reactive-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ref-与-reactive-的区别"}},[t._v("#")]),t._v(" "),e("strong",[t._v("ref 与 reactive 的区别？")])]),t._v(" "),e("ul",[e("li",[t._v("ref 与 reactive 它们主要用于响应式数据的创建")]),t._v(" "),e("li",[t._v("ref 函数可以接收原始数据类型和引用数据类型")]),t._v(" "),e("li",[t._v("使用 ref 声明的数据，在 js 中使用的时候，需要添加 .value 后缀")]),t._v(" "),e("li",[t._v("reactive 函数只能接收引用数据类型")]),t._v(" "),e("li",[t._v("ref 底层还是使用 reactive 来做，ref 是在 reactve 上进行了封装，增强了其能力，使其支持了对原始数据的支持")]),t._v(" "),e("li",[t._v("reactive 能做的 ref 能做，reactive 不能做的 ref 也能做")])])])}),[],!1,null,null,null);e.default=v.exports}}]);